---
title:  使用 Java 8 的优点是什么？
date: 2025-12-29 20:44:53
permalink: /pages/49f7b0/
categories:
  - 常见面试题
  - Java 8 + 特性类
tags:
  - 
---
#### 1. Lambda 表达式：简化代码，告别冗余匿名类
这是 Java 8 最直观的优点。它允许你将**行为**像数据一样传递，大幅简化了匿名内部类的写法，让代码更简洁、易读。

**对比示例**：遍历集合
- Java 7 及之前（匿名内部类）：
```java
List<String> list = Arrays.asList("Java", "Python", "C++");
// 遍历集合
for (String s : list) {
    System.out.println(s);
}
// 或使用匿名内部类（如排序）
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
```

- Java 8（Lambda 表达式）：
```java
List<String> list = Arrays.asList("Java", "Python", "C++");
// 遍历
list.forEach(s -> System.out.println(s));
// 排序
Collections.sort(list, (s1, s2) -> s1.length() - s2.length());
```
可以看到，Lambda 把原本需要写多行的匿名类代码简化成了一行，逻辑更聚焦。

#### 2. Stream API：高效处理集合，支持函数式编程
Stream API 是配合 Lambda 的“利器”，专门用于处理集合（List/Set/Map 等），支持**过滤、映射、排序、聚合**等操作，代码更简洁，还能轻松实现并行处理提升效率。

**示例：筛选并处理集合**
```java
List<String> list = Arrays.asList("Java8", "Python", "C++", "JavaSE");
// 需求：筛选以Java开头的字符串，转大写，收集到新列表
List<String> result = list.stream()
    .filter(s -> s.startsWith("Java")) // 过滤
    .map(String::toUpperCase) // 转换大写
    .collect(Collectors.toList()); // 收集结果
System.out.println(result); // 输出：[JAVA8, JAVASE]

// 并行处理（自动利用多核CPU）
List<String> parallelResult = list.parallelStream()
    .filter(s -> s.startsWith("Java"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```
相比传统的 for 循环遍历+判断，Stream API 让代码“声明式”（告诉程序要做什么，而非怎么做），可读性和维护性大幅提升。

#### 3. Optional 类：避免空指针异常（NPE）
空指针是 Java 开发中最常见的异常之一，Java 8 引入 `Optional` 类，通过封装可能为 null 的值，强制开发者处理 null 情况，从根源上减少 NPE。

**示例**：
```java
// Java 7 及之前：需要手动判空
String name = getUser().getName();
if (name != null) {
    System.out.println(name.length());
}

// Java 8：使用 Optional 优雅处理
Optional<String> optionalName = Optional.ofNullable(getUser().getName());
optionalName.ifPresent(n -> System.out.println(n.length())); // 仅当值非空时执行
String defaultName = optionalName.orElse("默认名称"); // 空时返回默认值
```

#### 4. 接口默认方法和静态方法：增强接口扩展性
Java 8 允许接口中定义 `default`（默认）方法和 `static`（静态）方法，解决了“接口修改导致所有实现类必须修改”的问题，让接口可以新增功能而不破坏现有代码。

**示例**：
```java
interface Greeting {
    // 抽象方法
    void sayHello();
    
    // 默认方法（实现类可直接使用，也可重写）
    default void sayHi() {
        System.out.println("Hi!");
    }
    
    // 静态方法
    static void sayGoodbye() {
        System.out.println("Goodbye!");
    }
}

class MyGreeting implements Greeting {
    @Override
    public void sayHello() {
        System.out.println("Hello!");
    }
}

// 使用
MyGreeting greeting = new MyGreeting();
greeting.sayHello(); // 输出：Hello!
greeting.sayHi(); // 输出：Hi!（直接使用接口默认方法）
Greeting.sayGoodbye(); // 输出：Goodbye!（调用接口静态方法）
```

#### 5. 其他实用改进
- **日期时间 API**：新增 `java.time` 包（LocalDate/LocalTime/LocalDateTime 等），替代了老旧的 `Date`/`Calendar`，解决了线程不安全、API 设计混乱的问题；
- **方法引用**：进一步简化 Lambda 表达式（如 `String::toUpperCase` 替代 `s -> s.toUpperCase()`）；
- **性能优化**：底层对 HashMap、ConcurrentHashMap 等集合做了优化，并行流利用 Fork/Join 框架提升处理效率。

### 总结
Java 8 最核心的优点可总结为 3 点：
1. **代码更简洁**：Lambda 表达式 + Stream API 大幅减少冗余代码，实现函数式编程风格；
2. **更健壮**：Optional 类有效避免空指针，接口默认方法提升代码扩展性；
3. **更高效**：Stream 并行处理、底层性能优化提升程序运行效率，新日期 API 解决旧 API 的痛点。
