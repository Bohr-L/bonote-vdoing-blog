---
title:  ArrayList、LinkedList、Vector 的区别？
date: 2025-12-29 22:02:16
permalink: /pages/1e1945/
categories:
  - 常见面试题
  - Java 8 + 特性类
tags:
  - 
---
这三个均是 Java 中`List`接口的实现类，核心差异在于 “**数据结构、性能、线程安全、功能特性**”，具体对比如下：

| 对比维度             | ArrayList                                           | LinkedList                                     | Vector                                                       |
| -------------------- | --------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 数据结构             | 动态数组（数组扩容）                                | 双向链表                                       | 动态数组（数组扩容）                                         |
| 线程安全             | 非线程安全                                          | 非线程安全                                     | 线程安全（方法加`synchronized`锁）                           |
| 访问效率（随机访问） | 高（数组支持索引访问，O (1)）                       | 低（需遍历链表，O (n)）                        | 高（数组支持索引访问，O (1)）                                |
| 增删效率（指定位置） | 低（需移动数组元素，O (n)）                         | 高（仅需修改链表指针，O (1)）                  | 低（需移动数组元素，O (n)）                                  |
| 扩容机制             | 初始容量 10，扩容时增长 50%（新容量 = 旧容量 ×1.5） | 无扩容机制（链表按需添加节点）                 | 初始容量 10，扩容时增长 100%（新容量 = 旧容量 ×2）           |
| 内存占用             | 连续内存，浪费较少（扩容时有冗余空间）              | 非连续内存，每个节点额外存储前后指针，浪费较多 | 连续内存，浪费较多（扩容增长比例大）                         |
| 核心用途             | 单线程场景，频繁随机访问、少量增删                  | 单线程场景，频繁增删、少量随机访问             | Legacy 代码（不推荐新使用），多线程场景可替代为`Collections.synchronizedList(new ArrayList<>())` |

#### 关键特性详解

- **ArrayList**：最常用的 List，动态数组结构适合随机访问（如`get(index)`），单线程下性能最优，适合 “读多写少” 场景；
- **LinkedList**：双向链表结构适合频繁增删（如`add(0, obj)`、`remove(0)`），但随机访问效率低，适合 “写多读少” 场景，还实现了`Deque`接口，支持队列 / 栈操作；
- **Vector**：古老的线程安全 List，通过`synchronized`修饰方法实现线程安全，但锁粒度大（全表锁），并发性能差，现在已被`ArrayList + Collections.synchronizedList()`或`CopyOnWriteArrayList`替代。

#### 优化建议

- 若已知数据量，创建 ArrayList 时指定初始容量（如`new ArrayList<>(100)`），减少扩容次数；
- 频繁在链表头部 / 尾部增删，优先用 LinkedList；
- 多线程场景，避免用 Vector，优先用`CopyOnWriteArrayList`（读无锁，写复制，适合读多写少）或`Collections.synchronizedList(new ArrayList<>())`。