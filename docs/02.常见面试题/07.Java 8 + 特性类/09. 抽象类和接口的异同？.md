---
title:  抽象类和接口的异同？
date: 2025-12-29 21:21:59
permalink: /pages/bf8914/
categories:
  - 常见面试题
  - Java 8 + 特性类
tags:
  - 
---
抽象类（`abstract class`）和接口（`interface`）是 Java 中实现抽象和多态的核心机制，在 “**定义、继承、方法特性**” 等方面既有共性也有差异：

#### 1. 相同点

- 均不能实例化：抽象类不能直接`new`，接口也不能直接`new`，需通过子类 / 实现类实例化；
- 均支持抽象方法：抽象类可包含抽象方法（`abstract`修饰），接口默认方法为抽象方法（Java 8 前）；
- 均支持多态：子类 / 实现类可重写抽象方法，实现统一接口下的不同行为；
- 均用于代码复用：抽象类通过继承复用代码，接口通过实现复用方法规范。

#### 2. 不同点

| 对比维度   | 抽象类（abstract class）                                 | 接口（interface）                                            |
| ---------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 继承方式   | 单继承（子类只能继承一个抽象类）                         | 多实现（类可实现多个接口）                                   |
| 方法特性   | 可包含抽象方法、普通方法、静态方法、默认方法             | Java 8 前：仅抽象方法；Java 8 后：支持抽象方法、静态方法、默认方法 |
| 字段特性   | 可包含任意字段（成员变量、静态变量），支持各种访问修饰符 | 字段默认`public static final`（常量），不能包含普通成员变量  |
| 构造方法   | 有构造方法（用于子类初始化）                             | 无构造方法                                                   |
| 访问修饰符 | 类：`public`/ 默认；方法 / 字段：任意访问修饰符          | 类：默认`public`；方法 / 字段：默认`public`（可省略）        |
| 核心用途   | 代码复用（子类继承共性方法）+ 抽象规范                   | 定义方法规范（多实现）+ 功能扩展（默认方法）                 |

#### 3. 适用场景

- 抽象类：需复用大量代码（如多个子类共享属性和方法），且子类之间存在 is-a 关系（如`Dog`是`Animal`）；
- 接口：需定义方法规范（不关心实现），且类需实现多个功能（如`Bird`实现`Flyable`和`Swimmable`）。

#### 示例

java



运行









```java
// 抽象类
abstract class Animal {
    // 成员变量
    protected String name;
    
    // 构造方法
    public Animal(String name) {
        this.name = name;
    }
    
    // 普通方法（可复用）
    public void eat() {
        System.out.println(name + "在吃饭");
    }
    
    // 抽象方法（规范）
    public abstract void move();
}

// 接口
interface Flyable {
    // 常量
    String TYPE = "飞行生物";
    
    // 抽象方法（规范）
    void fly();
    
    // 默认方法（扩展）
    default void showType() {
        System.out.println("类型：" + TYPE);
    }
}

// 子类继承抽象类+实现接口
class Bird extends Animal implements Flyable {
    public Bird(String name) {
        super(name);
    }
    
    @Override
    public void move() {
        System.out.println(name + "在跳跃");
    }
    
    @Override
    public void fly() {
        System.out.println(name + "在飞翔");
    }
}
```

### 