---
title:  聊一聊 MySQL 中的关联查询
date: 2025-12-29 11:15:02
permalink: /pages/a3c125/
categories:
  - 常见面试题
  - MySQL 类
tags:
  - 
---
MySQL 的关联查询（Join Query）是 “**从多个表中获取关联数据**” 的核心方式，基于表间的关联条件（如外键）将多个表的数据组合返回，常见的关联类型包括内连接、外连接、交叉连接，具体如下：

#### 1. 关联查询的核心概念

- **关联条件**：用于匹配多个表的字段（如`user.id = order.user_id`），若缺少关联条件，会产生 “笛卡尔积”（两个表的所有行两两组合，数据量为两表行数乘积，通常是错误结果）；
- **驱动表与被驱动表**：
    - 驱动表：关联查询时先执行的表（如`SELECT * FROM user JOIN order ON user.id = order.user_id`，`user`表是驱动表）；
    - 被驱动表：关联查询时后执行的表（`order`表是被驱动表）；
    - MySQL 会根据表的大小和索引选择驱动表（通常选择小表作为驱动表，减少被驱动表的查询次数）。

#### 2. 常见的关联查询类型

以 “用户表（user，主键 id）” 和 “订单表（order，外键 user_id 关联 user.id）” 为例，说明各关联类型的差异：

##### （1）内连接（INNER JOIN）：返回两表匹配的行

- **定义**：仅返回两个表中满足关联条件的行，不匹配的行（如无订单的用户、无用户的订单）不返回；

- **语法**：
  ```sql
  SELECT u.id, u.name, o.order_id
  FROM user u
  INNER JOIN `order` o ON u.id = o.user_id; -- 关联条件：user.id = order.user_id
  ```



- **结果示例**：

  | id   | name | order_id |
    | ---- | ---- | -------- |
  | 1    | 张三 | 1001     |
  | 1    | 张三 | 1002     |
  | 2    | 李四 | 1003     |

- **适用场景**：查询同时存在于两个表中的数据（如 “有订单的用户及其订单”）。

##### （2）左外连接（LEFT JOIN）：返回左表所有行，右表匹配的行

- **定义**：返回左表（JOIN 左侧的表）的所有行，右表（JOIN 右侧的表）中满足关联条件的行；若右表无匹配行，右表字段返回 NULL；

- **语法**：

  ```sql
  SELECT u.id, u.name, o.order_id
  FROM user u
  LEFT JOIN `order` o ON u.id = o.user_id;
  ```



- **结果示例**：

  | id   | name | order_id |                                   |
    | ---- | ---- | -------- | --------------------------------- |
  | 1    | 张三 | 1001     |                                   |
  | 1    | 张三 | 1002     |                                   |
  | 2    | 李四 | 1003     |                                   |
  | 3    | 王五 | NULL     | -- 王五无订单，order_id 返回 NULL |

- **适用场景**：查询左表所有数据，无论右表是否有匹配（如 “所有用户及其订单，无订单的用户也显示”）。

##### （3）右外连接（RIGHT JOIN）：返回右表所有行，左表匹配的行

- **定义**：与左外连接相反，返回右表的所有行，左表中满足关联条件的行；若左表无匹配行，左表字段返回 NULL；

- **语法**：

  ```sql
  SELECT u.id, u.name, o.order_id
  FROM user u
  RIGHT JOIN `order` o ON u.id = o.user_id;
  ```



- **结果示例**：

  | id   | name | order_id |                                               |
    | ---- | ---- | -------- | --------------------------------------------- |
  | 1    | 张三 | 1001     |                                               |
  | 1    | 张三 | 1002     |                                               |
  | 2    | 李四 | 1003     |                                               |
  | NULL | NULL | 1004     | -- 订单 1004 无对应的用户，user 字段返回 NULL |

- **适用场景**：查询右表所有数据，无论左表是否有匹配（如 “所有订单及其用户，无用户的订单也显示”）。

##### （4）全外连接（FULL JOIN）：返回两表所有行（MySQL 不直接支持）

- **定义**：返回左表和右表的所有行，匹配的行合并，不匹配的行对应字段返回 NULL；

- **MySQL 实现方式**：MySQL 不直接支持`FULL JOIN`，需通过`LEFT JOIN + UNION + RIGHT JOIN`实现：
  ```sql
  SELECT u.id, u.name, o.order_id
  FROM user u
  LEFT JOIN `order` o ON u.id = o.user_id
  UNION -- 合并结果，去重
  SELECT u.id, u.name, o.order_id
  FROM user u
  RIGHT JOIN `order` o ON u.id = o.user_id;
  ```



- **结果示例**：包含左外连接和右外连接的所有行，无重复。

##### （5）交叉连接（CROSS JOIN）：笛卡尔积

- **定义**：无关联条件的连接，返回两表所有行的笛卡尔积（数据量 = 左表行数 × 右表行数），通常无实际业务意义，需避免；

- **语法**：
  ```sql
  SELECT u.id, u.name, o.order_id
  FROM user u
  CROSS JOIN `order` o; -- 无关联条件
  ```



- **风险**：若左表有 1000 行，右表有 1000 行，返回 100 万行数据，严重影响性能。
#### 3. 关联查询的性能优化

关联查询的性能瓶颈通常在于 “被驱动表的查询效率”，核心优化思路是 “**减少被驱动表的查询次数、利用索引加速匹配**”，具体方案：

- **1. 给关联字段建立索引**：
    - 被驱动表的关联字段（如`order.user_id`）必须建立索引，避免被驱动表全表扫描（关联查询时，驱动表的每行数据都会去被驱动表匹配，无索引则每次匹配都是全表扫描）；
    - 驱动表的关联字段若有索引，可提升驱动表的过滤效率（如`user.id`是主键索引，驱动表查询时可快速定位符合条件的行）。
- **2. 选择合适的驱动表**：
    - 遵循 “小表驱动大表” 原则：驱动表数据量越小，被驱动表的查询次数越少（如驱动表有 100 行，被驱动表查询 100 次；驱动表有 1000 行，被驱动表查询 1000 次）；
    - MySQL 的优化器会自动选择小表作为驱动表，但需确保统计信息准确（可通过`ANALYZE TABLE`更新表统计信息）。
- **3. 减少查询字段**：
    - 避免`SELECT *`，只查询需要的字段（如`SELECT u.name, o.order_id`），减少数据传输和内存消耗；
    - 被驱动表的查询字段若包含在索引中（覆盖索引），可避免回表（如`order`表的索引`idx_userid_orderid`包含`user_id`和`order_id`，查询时无需访问数据文件）。
- **4. 避免复杂条件在被驱动表**：
    - 尽量在驱动表中过滤数据（如`WHERE u.age > 20`），减少驱动表的行数，从而减少被驱动表的查询次数；
    - 避免在被驱动表的关联字段上做函数操作（如`ON u.id = SUBSTR(o.user_id_str, 2)`），会导致索引失效。
- **5. 控制关联表数量**：
    - 避免超过 3 张表的关联查询（多表关联会增加优化器的计算复杂度，且容易导致索引失效）；
    - 若需多表关联，可拆分查询（先查询两张表的结果，存入临时表，再与第三张表关联）。