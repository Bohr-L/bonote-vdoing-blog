---
title:  接口防刷怎么实现？
date: 2025-12-29 22:21:11
permalink: /pages/ac2e24/
categories:
  - 常见面试题
  - 其他技术类
tags:
  - 
---
接口防刷是指 “**防止第三方或恶意用户高频调用接口，导致服务过载、数据泄露或业务损失**”，核心实现思路是 “**限制调用频率、识别恶意请求、拦截非法调用**”，具体方案如下：

#### 1. 核心实现方案

- **方案 1：基于限流的防刷（最常用）**

    - 原理：限制单位时间内的接口调用次数（如单 IP / 单用户 / 单 AppID 每秒最多调用 10 次）；

    - 实现方式：

        - 本地缓存：用 Guava RateLimiter（令牌桶算法）、Caffeine 缓存记录调用次数，适合单实例服务；
        - 分布式缓存：用 Redis 记录调用次数（如`SET key 1 EX 10 NX`，`INCR key`统计次数），适合多实例服务；

    - 示例（Redis 实现）：

      java



    运行

    

    

    

    

    ```java
    // 接口调用前检查
    public boolean checkLimit(String key, int limit, int expireSeconds) {
        String redisKey = "api_limit:" + key; // key可设为IP+接口名、AppID+接口名
        Long count = redisTemplate.opsForValue().increment(redisKey, 1);
        if (count == 1) {
            redisTemplate.expire(redisKey, expireSeconds, TimeUnit.SECONDS); // 设置过期时间
        }
        return count <= limit; // 超过限制返回false
    }
    ```



- **方案 2：基于验证码的防刷**

    - 原理：高频接口（如登录、注册、发送短信）调用前，要求用户输入图形验证码、短信验证码，验证通过后才允许调用；
    - 适用场景：非机器调用场景（如用户操作接口），防止恶意脚本批量调用；
    - 实现方式：集成第三方验证码服务（如极验、腾讯云验证码），或自建验证码生成接口。

- **方案 3：基于黑名单的防刷**

    - 原理：识别恶意请求源（如频繁触发限流的 IP、多次调用失败的账号），加入黑名单，禁止后续调用；
    - 实现方式：用 Redis 存储黑名单（如`SADD blacklist:ip 192.168.1.1`），接口调用前先检查是否在黑名单中；
    - 策略：黑名单设置过期时间（如 24 小时），避免误封后无法恢复。

- **方案 4：基于请求特征的防刷**

    - 原理：分析请求特征（如请求头异常、参数固定、无 Referer），识别机器调用或恶意请求；
    - 实现方式：
        - 校验请求头：要求携带合法的`User-Agent`、`Referer`；
        - 检查参数：避免参数重复（如短信接口的手机号 + 验证码组合）、参数异常（如手机号格式错误）；
        - 行为分析：如短时间内同一 IP 调用多个不同接口、请求间隔固定（机器特征）。

#### 2. 进阶优化

- **分层限流**：接口层（Nginx 限流）+ 应用层（Redis 限流）+ 业务层（验证码），多层防护；
- **动态调整阈值**：根据服务负载动态调整限流阈值（如高峰期阈值降低，低峰期阈值提高）；
- **幂等性配合**：核心接口实现幂等性，即使限流失效，也不会因重复调用导致业务异常；
- **告警机制**：频繁触发限流、黑名单新增时及时告警，人工介入排查恶意请求。