---
title:  什么是内存屏障？JVM 如何使用内存屏障保证指令执行顺序？
date: 2025-12-28 23:16:58
permalink: /pages/625a9f/
categories:
  - 常见面试题
  - JVM 类
tags:
  - 
---
#### 1. 内存屏障（Memory Barrier）的定义

内存屏障是**硬件层面的指令**，用于解决 “CPU 乱序执行” 和 “缓存一致性” 问题，确保内存操作（读 / 写）的执行顺序和可见性。在多线程场景中，若缺乏内存屏障，CPU 可能为提升效率对指令重排序，导致线程间数据可见性问题（如线程 A 修改的变量，线程 B 无法及时读取到最新值）。

#### 2. 内存屏障的核心作用

- **（1）禁止指令重排序**：阻止 CPU 对内存屏障前后的指令进行重排序，确保指令按代码顺序执行；
- **（2）保证内存可见性**：强制将 CPU 缓存中的数据刷新到主内存（写屏障），或从主内存重新加载数据到 CPU 缓存（读屏障），确保线程间数据的一致性。

#### 3. 内存屏障的分类（按功能）

根据作用对象（读 / 写操作），内存屏障分为 4 类：

| 屏障类型            | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| **LoadLoad 屏障**   | 确保屏障前的 “读操作”（Load）完成后，再执行屏障后的 “读操作” |
| **StoreStore 屏障** | 确保屏障前的 “写操作”（Store）完成并刷新到主内存后，再执行屏障后的 “写操作” |
| **LoadStore 屏障**  | 确保屏障前的 “读操作” 完成后，再执行屏障后的 “写操作”        |
| **StoreLoad 屏障**  | 确保屏障前的 “写操作” 完成并刷新到主内存后，再执行屏障后的 “读操作” |

- **说明**：StoreLoad 屏障功能最全面（可覆盖其他屏障的作用），但性能开销最大，需谨慎使用。

#### 4. JVM 如何使用内存屏障

JVM 通过在字节码中插入内存屏障，确保 “happen-before 原则”（Java 内存模型的核心，定义线程间操作的可见性规则）的实现，具体场景包括：

##### （1）volatile 关键字的实现

`volatile`修饰的变量具有 “可见性” 和 “禁止指令重排序” 特性，JVM 通过插入内存屏障实现：

- **写操作（volatile 变量赋值）**：在赋值指令后插入**StoreStore 屏障**和**StoreLoad 屏障**：
    - StoreStore 屏障：确保 volatile 变量的写操作完成后，再执行其他普通变量的写操作；
    - StoreLoad 屏障：确保 volatile 变量的写操作刷新到主内存后，再执行后续的读操作（避免其他线程读取到旧值）；
- **读操作（volatile 变量取值）**：在取值指令前插入**LoadLoad 屏障**和**LoadStore 屏障**：
    - LoadLoad 屏障：确保 volatile 变量的读操作完成后，再执行其他普通变量的读操作；
    - LoadStore 屏障：确保 volatile 变量的读操作完成后，再执行其他普通变量的写操作。

##### （2）synchronized 关键字的实现

`synchronized`的 “锁释放” 和 “锁获取” 过程隐含内存屏障：

- **锁释放（退出同步块）**：JVM 在锁释放位置插入**StoreStore 屏障**和**StoreLoad 屏障**，确保同步块内的写操作全部刷新到主内存，其他线程获取锁后可读取到最新值；
- **锁获取（进入同步块）**：JVM 在锁获取位置插入**LoadLoad 屏障**和**LoadStore 屏障**，确保线程获取锁后，从主内存重新加载变量值，避免使用缓存中的旧值。

##### （3）final 关键字的实现

`final`修饰的变量具有 “不可变” 特性（初始化后无法修改），JVM 通过内存屏障确保`final`变量的初始化可见性：

- 在`final`变量初始化完成后、构造函数返回前，插入**StoreStore 屏障**，确保`final`变量的写操作完成后，再执行构造函数的其他写操作（避免其他线程看到未初始化完成的`final`变量）。